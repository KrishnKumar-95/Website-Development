{"ast":null,"code":"import { EnterLeaveCounter } from './EnterLeaveCounter.mjs';\nimport { getNodeClientOffset, getEventClientOffset, getDragPreviewOffset } from './OffsetUtils.mjs';\nimport { createNativeDragSource, matchNativeItemType } from './NativeDragSources/index.mjs';\nimport * as NativeTypes from './NativeTypes.mjs';\nimport { OptionsReader } from './OptionsReader.mjs';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nexport class HTML5BackendImpl {\n  /**\n  * Generate profiling statistics for the HTML5Backend.\n  */\n  profile() {\n    var ref, ref1;\n    return {\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      sourceNodeOptions: this.sourceNodeOptions.size,\n      sourceNodes: this.sourceNodes.size,\n      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n      dropTargetIds: this.dropTargetIds.length,\n      dragEnterTargetIds: this.dragEnterTargetIds.length,\n      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n    };\n  } // public for test\n\n\n  get window() {\n    return this.options.window;\n  }\n\n  get document() {\n    return this.options.document;\n  }\n  /**\n  * Get the root element to use for event subscriptions\n  */\n\n\n  get rootElement() {\n    return this.options.rootElement;\n  }\n\n  setup() {\n    const root = this.rootElement;\n\n    if (root === undefined) {\n      return;\n    }\n\n    if (root.__isReactDndBackendSetUp) {\n      throw new Error('Cannot have two HTML5 backends at the same time.');\n    }\n\n    root.__isReactDndBackendSetUp = true;\n    this.addEventListeners(root);\n  }\n\n  teardown() {\n    const root = this.rootElement;\n\n    if (root === undefined) {\n      return;\n    }\n\n    root.__isReactDndBackendSetUp = false;\n    this.removeEventListeners(this.rootElement);\n    this.clearCurrentDragSourceNode();\n\n    if (this.asyncEndDragFrameId) {\n      var ref;\n      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n    }\n  }\n\n  connectDragPreview(sourceId, node, options) {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n\n  connectDragSource(sourceId, node, options) {\n    this.sourceNodes.set(sourceId, node);\n    this.sourceNodeOptions.set(sourceId, options);\n\n    const handleDragStart = e => this.handleDragStart(e, sourceId);\n\n    const handleSelectStart = e => this.handleSelectStart(e);\n\n    node.setAttribute('draggable', 'true');\n    node.addEventListener('dragstart', handleDragStart);\n    node.addEventListener('selectstart', handleSelectStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      this.sourceNodeOptions.delete(sourceId);\n      node.removeEventListener('dragstart', handleDragStart);\n      node.removeEventListener('selectstart', handleSelectStart);\n      node.setAttribute('draggable', 'false');\n    };\n  }\n\n  connectDropTarget(targetId, node) {\n    const handleDragEnter = e => this.handleDragEnter(e, targetId);\n\n    const handleDragOver = e => this.handleDragOver(e, targetId);\n\n    const handleDrop = e => this.handleDrop(e, targetId);\n\n    node.addEventListener('dragenter', handleDragEnter);\n    node.addEventListener('dragover', handleDragOver);\n    node.addEventListener('drop', handleDrop);\n    return () => {\n      node.removeEventListener('dragenter', handleDragEnter);\n      node.removeEventListener('dragover', handleDragOver);\n      node.removeEventListener('drop', handleDrop);\n    };\n  }\n\n  addEventListeners(target) {\n    // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n    if (!target.addEventListener) {\n      return;\n    }\n\n    target.addEventListener('dragstart', this.handleTopDragStart);\n    target.addEventListener('dragstart', this.handleTopDragStartCapture, true);\n    target.addEventListener('dragend', this.handleTopDragEndCapture, true);\n    target.addEventListener('dragenter', this.handleTopDragEnter);\n    target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);\n    target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n    target.addEventListener('dragover', this.handleTopDragOver);\n    target.addEventListener('dragover', this.handleTopDragOverCapture, true);\n    target.addEventListener('drop', this.handleTopDrop);\n    target.addEventListener('drop', this.handleTopDropCapture, true);\n  }\n\n  removeEventListeners(target) {\n    // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n    if (!target.removeEventListener) {\n      return;\n    }\n\n    target.removeEventListener('dragstart', this.handleTopDragStart);\n    target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);\n    target.removeEventListener('dragend', this.handleTopDragEndCapture, true);\n    target.removeEventListener('dragenter', this.handleTopDragEnter);\n    target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);\n    target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n    target.removeEventListener('dragover', this.handleTopDragOver);\n    target.removeEventListener('dragover', this.handleTopDragOverCapture, true);\n    target.removeEventListener('drop', this.handleTopDrop);\n    target.removeEventListener('drop', this.handleTopDropCapture, true);\n  }\n\n  getCurrentSourceNodeOptions() {\n    const sourceId = this.monitor.getSourceId();\n    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n    return _objectSpread({\n      dropEffect: this.altKeyPressed ? 'copy' : 'move'\n    }, sourceNodeOptions || {});\n  }\n\n  getCurrentDropEffect() {\n    if (this.isDraggingNativeItem()) {\n      // It makes more sense to default to 'copy' for native resources\n      return 'copy';\n    }\n\n    return this.getCurrentSourceNodeOptions().dropEffect;\n  }\n\n  getCurrentSourcePreviewNodeOptions() {\n    const sourceId = this.monitor.getSourceId();\n    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n    return _objectSpread({\n      anchorX: 0.5,\n      anchorY: 0.5,\n      captureDraggingState: false\n    }, sourcePreviewNodeOptions || {});\n  }\n\n  isDraggingNativeItem() {\n    const itemType = this.monitor.getItemType();\n    return Object.keys(NativeTypes).some(key => NativeTypes[key] === itemType);\n  }\n\n  beginDragNativeItem(type, dataTransfer) {\n    this.clearCurrentDragSourceNode();\n    this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n    this.actions.beginDrag([this.currentNativeHandle]);\n  }\n\n  setCurrentDragSourceNode(node) {\n    this.clearCurrentDragSourceNode();\n    this.currentDragSourceNode = node; // A timeout of > 0 is necessary to resolve Firefox issue referenced\n    // See:\n    //   * https://github.com/react-dnd/react-dnd/pull/928\n    //   * https://github.com/react-dnd/react-dnd/issues/869\n\n    const MOUSE_MOVE_TIMEOUT = 1000; // Receiving a mouse event in the middle of a dragging operation\n    // means it has ended and the drag source node disappeared from DOM,\n    // so the browser didn't dispatch the dragend event.\n    //\n    // We need to wait before we start listening for mousemove events.\n    // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n    // immediately in some browsers.\n    //\n    // See:\n    //   * https://github.com/react-dnd/react-dnd/pull/928\n    //   * https://github.com/react-dnd/react-dnd/issues/869\n    //\n\n    this.mouseMoveTimeoutTimer = setTimeout(() => {\n      var ref;\n      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n    }, MOUSE_MOVE_TIMEOUT);\n  }\n\n  clearCurrentDragSourceNode() {\n    if (this.currentDragSourceNode) {\n      this.currentDragSourceNode = null;\n\n      if (this.rootElement) {\n        var ref;\n        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);\n        this.rootElement.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n      }\n\n      this.mouseMoveTimeoutTimer = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  handleDragStart(e, sourceId) {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    if (!this.dragStartSourceIds) {\n      this.dragStartSourceIds = [];\n    }\n\n    this.dragStartSourceIds.unshift(sourceId);\n  }\n\n  handleDragEnter(_e, targetId) {\n    this.dragEnterTargetIds.unshift(targetId);\n  }\n\n  handleDragOver(_e, targetId) {\n    if (this.dragOverTargetIds === null) {\n      this.dragOverTargetIds = [];\n    }\n\n    this.dragOverTargetIds.unshift(targetId);\n  }\n\n  handleDrop(_e, targetId) {\n    this.dropTargetIds.unshift(targetId);\n  }\n\n  constructor(manager, globalContext, options) {\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.sourceNodes = new Map();\n    this.sourceNodeOptions = new Map();\n    this.dragStartSourceIds = null;\n    this.dropTargetIds = [];\n    this.dragEnterTargetIds = [];\n    this.currentNativeSource = null;\n    this.currentNativeHandle = null;\n    this.currentDragSourceNode = null;\n    this.altKeyPressed = false;\n    this.mouseMoveTimeoutTimer = null;\n    this.asyncEndDragFrameId = null;\n    this.dragOverTargetIds = null;\n    this.lastClientOffset = null;\n    this.hoverRafId = null;\n\n    this.getSourceClientOffset = sourceId => {\n      const source = this.sourceNodes.get(sourceId);\n      return source && getNodeClientOffset(source) || null;\n    };\n\n    this.endDragNativeItem = () => {\n      if (!this.isDraggingNativeItem()) {\n        return;\n      }\n\n      this.actions.endDrag();\n\n      if (this.currentNativeHandle) {\n        this.registry.removeSource(this.currentNativeHandle);\n      }\n\n      this.currentNativeHandle = null;\n      this.currentNativeSource = null;\n    };\n\n    this.isNodeInDocument = node => {\n      // Check the node either in the main document or in the current context\n      return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n    };\n\n    this.endDragIfSourceWasRemovedFromDOM = () => {\n      const node = this.currentDragSourceNode;\n\n      if (node == null || this.isNodeInDocument(node)) {\n        return;\n      }\n\n      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n    };\n\n    this.handleTopDragStartCapture = () => {\n      this.clearCurrentDragSourceNode();\n      this.dragStartSourceIds = [];\n    };\n\n    this.handleTopDragStart = e => {\n      if (e.defaultPrevented) {\n        return;\n      }\n\n      const {\n        dragStartSourceIds\n      } = this;\n      this.dragStartSourceIds = null;\n      const clientOffset = getEventClientOffset(e); // Avoid crashing if we missed a drop event or our previous drag died\n\n      if (this.monitor.isDragging()) {\n        this.actions.endDrag();\n      } // Don't publish the source just yet (see why below)\n\n\n      this.actions.beginDrag(dragStartSourceIds || [], {\n        publishSource: false,\n        getSourceClientOffset: this.getSourceClientOffset,\n        clientOffset\n      });\n      const {\n        dataTransfer\n      } = e;\n      const nativeType = matchNativeItemType(dataTransfer);\n\n      if (this.monitor.isDragging()) {\n        if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {\n          // Use custom drag image if user specifies it.\n          // If child drag source refuses drag but parent agrees,\n          // use parent's node as drag image. Neither works in IE though.\n          const sourceId = this.monitor.getSourceId();\n          const sourceNode = this.sourceNodes.get(sourceId);\n          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n\n          if (dragPreview) {\n            const {\n              anchorX,\n              anchorY,\n              offsetX,\n              offsetY\n            } = this.getCurrentSourcePreviewNodeOptions();\n            const anchorPoint = {\n              anchorX,\n              anchorY\n            };\n            const offsetPoint = {\n              offsetX,\n              offsetY\n            };\n            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n          }\n        }\n\n        try {\n          // Firefox won't drag without setting data\n          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData('application/json', {});\n        } catch (err) {// IE doesn't support MIME types in setData\n        } // Store drag source node so we can check whether\n        // it is removed from DOM and trigger endDrag manually.\n\n\n        this.setCurrentDragSourceNode(e.target); // Now we are ready to publish the drag source.. or are we not?\n\n        const {\n          captureDraggingState\n        } = this.getCurrentSourcePreviewNodeOptions();\n\n        if (!captureDraggingState) {\n          // Usually we want to publish it in the next tick so that browser\n          // is able to screenshot the current (not yet dragging) state.\n          //\n          // It also neatly avoids a situation where render() returns null\n          // in the same tick for the source element, and browser freaks out.\n          setTimeout(() => this.actions.publishDragSource(), 0);\n        } else {\n          // In some cases the user may want to override this behavior, e.g.\n          // to work around IE not supporting custom drag previews.\n          //\n          // When using a custom drag layer, the only way to prevent\n          // the default drag preview from drawing in IE is to screenshot\n          // the dragging state in which the node itself has zero opacity\n          // and height. In this case, though, returning null from render()\n          // will abruptly end the dragging, which is not obvious.\n          //\n          // This is the reason such behavior is strictly opt-in.\n          this.actions.publishDragSource();\n        }\n      } else if (nativeType) {\n        // A native item (such as URL) dragged from inside the document\n        this.beginDragNativeItem(nativeType);\n      } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {\n        // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n        // Just let it drag. It's a native type (URL or text) and will be picked up in\n        // dragenter handler.\n        return;\n      } else {\n        // If by this time no drag source reacted, tell browser not to drag.\n        e.preventDefault();\n      }\n    };\n\n    this.handleTopDragEndCapture = () => {\n      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n        // Firefox can dispatch this event in an infinite loop\n        // if dragend handler does something like showing an alert.\n        // Only proceed if we have not handled it already.\n        this.actions.endDrag();\n      }\n    };\n\n    this.handleTopDragEnterCapture = e => {\n      this.dragEnterTargetIds = [];\n\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n      }\n\n      const isFirstEnter = this.enterLeaveCounter.enter(e.target);\n\n      if (!isFirstEnter || this.monitor.isDragging()) {\n        return;\n      }\n\n      const {\n        dataTransfer\n      } = e;\n      const nativeType = matchNativeItemType(dataTransfer);\n\n      if (nativeType) {\n        // A native item (such as file or URL) dragged from outside the document\n        this.beginDragNativeItem(nativeType, dataTransfer);\n      }\n    };\n\n    this.handleTopDragEnter = e => {\n      const {\n        dragEnterTargetIds\n      } = this;\n      this.dragEnterTargetIds = [];\n\n      if (!this.monitor.isDragging()) {\n        // This is probably a native item type we don't understand.\n        return;\n      }\n\n      this.altKeyPressed = e.altKey; // If the target changes position as the result of `dragenter`, `dragover` might still\n      // get dispatched despite target being no longer there. The easy solution is to check\n      // whether there actually is a target before firing `hover`.\n\n      if (dragEnterTargetIds.length > 0) {\n        this.actions.hover(dragEnterTargetIds, {\n          clientOffset: getEventClientOffset(e)\n        });\n      }\n\n      const canDrop = dragEnterTargetIds.some(targetId => this.monitor.canDropOnTarget(targetId));\n\n      if (canDrop) {\n        // IE requires this to fire dragover events\n        e.preventDefault();\n\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n        }\n      }\n    };\n\n    this.handleTopDragOverCapture = e => {\n      this.dragOverTargetIds = [];\n\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n      }\n    };\n\n    this.handleTopDragOver = e => {\n      const {\n        dragOverTargetIds\n      } = this;\n      this.dragOverTargetIds = [];\n\n      if (!this.monitor.isDragging()) {\n        // This is probably a native item type we don't understand.\n        // Prevent default \"drop and blow away the whole document\" action.\n        e.preventDefault();\n\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = 'none';\n        }\n\n        return;\n      }\n\n      this.altKeyPressed = e.altKey;\n      this.lastClientOffset = getEventClientOffset(e);\n\n      if (this.hoverRafId === null && typeof requestAnimationFrame !== 'undefined') {\n        this.hoverRafId = requestAnimationFrame(() => {\n          if (this.monitor.isDragging()) {\n            this.actions.hover(dragOverTargetIds || [], {\n              clientOffset: this.lastClientOffset\n            });\n          }\n\n          this.hoverRafId = null;\n        });\n      }\n\n      const canDrop = (dragOverTargetIds || []).some(targetId => this.monitor.canDropOnTarget(targetId));\n\n      if (canDrop) {\n        // Show user-specified drop effect.\n        e.preventDefault();\n\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n        }\n      } else if (this.isDraggingNativeItem()) {\n        // Don't show a nice cursor but still prevent default\n        // \"drop and blow away the whole document\" action.\n        e.preventDefault();\n      } else {\n        e.preventDefault();\n\n        if (e.dataTransfer) {\n          e.dataTransfer.dropEffect = 'none';\n        }\n      }\n    };\n\n    this.handleTopDragLeaveCapture = e => {\n      if (this.isDraggingNativeItem()) {\n        e.preventDefault();\n      }\n\n      const isLastLeave = this.enterLeaveCounter.leave(e.target);\n\n      if (!isLastLeave) {\n        return;\n      }\n\n      if (this.isDraggingNativeItem()) {\n        setTimeout(() => this.endDragNativeItem(), 0);\n      }\n    };\n\n    this.handleTopDropCapture = e => {\n      this.dropTargetIds = [];\n\n      if (this.isDraggingNativeItem()) {\n        var ref;\n        e.preventDefault();\n        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n      } else if (matchNativeItemType(e.dataTransfer)) {\n        // Dragging some elements, like <a> and <img> may still behave like a native drag event,\n        // even if the current drag event matches a user-defined type.\n        // Stop the default behavior when we're not expecting a native item to be dropped.\n        e.preventDefault();\n      }\n\n      this.enterLeaveCounter.reset();\n    };\n\n    this.handleTopDrop = e => {\n      const {\n        dropTargetIds\n      } = this;\n      this.dropTargetIds = [];\n      this.actions.hover(dropTargetIds, {\n        clientOffset: getEventClientOffset(e)\n      });\n      this.actions.drop({\n        dropEffect: this.getCurrentDropEffect()\n      });\n\n      if (this.isDraggingNativeItem()) {\n        this.endDragNativeItem();\n      } else if (this.monitor.isDragging()) {\n        this.actions.endDrag();\n      }\n    };\n\n    this.handleSelectStart = e => {\n      const target = e.target; // Only IE requires us to explicitly say\n      // we want drag drop operation to start\n\n      if (typeof target.dragDrop !== 'function') {\n        return;\n      } // Inputs and textareas should be selectable\n\n\n      if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n        return;\n      } // For other targets, ask IE\n      // to enable drag and drop\n\n\n      e.preventDefault();\n      target.dragDrop();\n    };\n\n    this.options = new OptionsReader(globalContext, options);\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.registry = manager.getRegistry();\n    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n  }\n\n}","map":{"version":3,"sources":["/home/ubkrishn/Desktop/Website Development/reactjs/react_by_krishn/react-dragNdrop-chakra_ui/node_modules/react-dnd-html5-backend/src/HTML5BackendImpl.ts"],"names":["EnterLeaveCounter","getNodeClientOffset","getEventClientOffset","getDragPreviewOffset","createNativeDragSource","matchNativeItemType","NativeTypes","OptionsReader","HTML5BackendImpl","sourcePreviewNodes","Map","sourcePreviewNodeOptions","sourceNodes","sourceNodeOptions","dragStartSourceIds","dropTargetIds","dragEnterTargetIds","currentNativeSource","currentNativeHandle","currentDragSourceNode","altKeyPressed","mouseMoveTimeoutTimer","asyncEndDragFrameId","dragOverTargetIds","lastClientOffset","hoverRafId","manager","globalContext","options","actions","getActions","monitor","getMonitor","registry","getRegistry","enterLeaveCounter","isNodeInDocument","profile","size","length","window","document","rootElement","setup","root","undefined","__isReactDndBackendSetUp","Error","addEventListeners","teardown","removeEventListeners","clearCurrentDragSourceNode","cancelAnimationFrame","connectDragPreview","sourceId","node","set","delete","connectDragSource","handleDragStart","e","handleSelectStart","setAttribute","addEventListener","removeEventListener","connectDropTarget","targetId","handleDragEnter","handleDragOver","handleDrop","target","handleTopDragStart","handleTopDragStartCapture","handleTopDragEndCapture","handleTopDragEnter","handleTopDragEnterCapture","handleTopDragLeaveCapture","handleTopDragOver","handleTopDragOverCapture","handleTopDrop","handleTopDropCapture","getCurrentSourceNodeOptions","getSourceId","get","dropEffect","getCurrentDropEffect","isDraggingNativeItem","getCurrentSourcePreviewNodeOptions","anchorX","anchorY","captureDraggingState","getSourceClientOffset","source","itemType","getItemType","Object","keys","some","key","beginDragNativeItem","type","dataTransfer","addSource","beginDrag","endDragNativeItem","endDrag","removeSource","Boolean","body","contains","endDragIfSourceWasRemovedFromDOM","isDragging","setCurrentDragSourceNode","MOUSE_MOVE_TIMEOUT","setTimeout","clearTimeout","defaultPrevented","unshift","clientOffset","publishSource","nativeType","setDragImage","sourceNode","dragPreview","offsetX","offsetY","anchorPoint","offsetPoint","dragPreviewOffset","x","y","setData","err","publishDragSource","types","hasAttribute","preventDefault","loadDataTransfer","isFirstEnter","enter","_e","altKey","hover","canDrop","canDropOnTarget","requestAnimationFrame","isLastLeave","leave","reset","drop","dragDrop","tagName","isContentEditable"],"mappings":"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","sourcesContent":["import type {\n\tBackend,\n\tDragDropManager,\n\tDragDropActions,\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n\tXYCoord,\n\tUnsubscribe,\n} from 'dnd-core'\nimport { EnterLeaveCounter } from './EnterLeaveCounter.js'\nimport {\n\tgetNodeClientOffset,\n\tgetEventClientOffset,\n\tgetDragPreviewOffset,\n} from './OffsetUtils.js'\nimport {\n\tcreateNativeDragSource,\n\tmatchNativeItemType,\n} from './NativeDragSources/index.js'\nimport * as NativeTypes from './NativeTypes.js'\nimport type { NativeDragSource } from './NativeDragSources/NativeDragSource.js'\nimport { OptionsReader } from './OptionsReader.js'\nimport type { HTML5BackendContext, HTML5BackendOptions } from './types.js'\n\ntype RootNode = Node & { __isReactDndBackendSetUp: boolean | undefined }\n\nexport class HTML5BackendImpl implements Backend {\n\tprivate options: OptionsReader\n\n\t// React-Dnd Components\n\tprivate actions: DragDropActions\n\tprivate monitor: DragDropMonitor\n\tprivate registry: HandlerRegistry\n\n\t// Internal State\n\tprivate enterLeaveCounter: EnterLeaveCounter\n\n\tprivate sourcePreviewNodes: Map<string, Element> = new Map()\n\tprivate sourcePreviewNodeOptions: Map<string, any> = new Map()\n\tprivate sourceNodes: Map<string, Element> = new Map()\n\tprivate sourceNodeOptions: Map<string, any> = new Map()\n\n\tprivate dragStartSourceIds: string[] | null = null\n\tprivate dropTargetIds: string[] = []\n\tprivate dragEnterTargetIds: string[] = []\n\tprivate currentNativeSource: NativeDragSource | null = null\n\tprivate currentNativeHandle: Identifier | null = null\n\tprivate currentDragSourceNode: Element | null = null\n\tprivate altKeyPressed = false\n\tprivate mouseMoveTimeoutTimer: number | null = null\n\tprivate asyncEndDragFrameId: number | null = null\n\tprivate dragOverTargetIds: string[] | null = null\n\n\tprivate lastClientOffset: XYCoord | null = null\n\tprivate hoverRafId: number | null = null\n\n\tpublic constructor(\n\t\tmanager: DragDropManager,\n\t\tglobalContext?: HTML5BackendContext,\n\t\toptions?: HTML5BackendOptions,\n\t) {\n\t\tthis.options = new OptionsReader(globalContext, options)\n\t\tthis.actions = manager.getActions()\n\t\tthis.monitor = manager.getMonitor()\n\t\tthis.registry = manager.getRegistry()\n\t\tthis.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument)\n\t}\n\n\t/**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */\n\tpublic profile(): Record<string, number> {\n\t\treturn {\n\t\t\tsourcePreviewNodes: this.sourcePreviewNodes.size,\n\t\t\tsourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n\t\t\tsourceNodeOptions: this.sourceNodeOptions.size,\n\t\t\tsourceNodes: this.sourceNodes.size,\n\t\t\tdragStartSourceIds: this.dragStartSourceIds?.length || 0,\n\t\t\tdropTargetIds: this.dropTargetIds.length,\n\t\t\tdragEnterTargetIds: this.dragEnterTargetIds.length,\n\t\t\tdragOverTargetIds: this.dragOverTargetIds?.length || 0,\n\t\t}\n\t}\n\n\t// public for test\n\tpublic get window(): Window | undefined {\n\t\treturn this.options.window\n\t}\n\tpublic get document(): Document | undefined {\n\t\treturn this.options.document\n\t}\n\t/**\n\t * Get the root element to use for event subscriptions\n\t */\n\tprivate get rootElement(): Node | undefined {\n\t\treturn this.options.rootElement as Node\n\t}\n\n\tpublic setup(): void {\n\t\tconst root = this.rootElement as RootNode | undefined\n\t\tif (root === undefined) {\n\t\t\treturn\n\t\t}\n\n\t\tif (root.__isReactDndBackendSetUp) {\n\t\t\tthrow new Error('Cannot have two HTML5 backends at the same time.')\n\t\t}\n\t\troot.__isReactDndBackendSetUp = true\n\t\tthis.addEventListeners(root)\n\t}\n\n\tpublic teardown(): void {\n\t\tconst root = this.rootElement as RootNode\n\t\tif (root === undefined) {\n\t\t\treturn\n\t\t}\n\n\t\troot.__isReactDndBackendSetUp = false\n\t\tthis.removeEventListeners(this.rootElement as Element)\n\t\tthis.clearCurrentDragSourceNode()\n\t\tif (this.asyncEndDragFrameId) {\n\t\t\tthis.window?.cancelAnimationFrame(this.asyncEndDragFrameId)\n\t\t}\n\t}\n\n\tpublic connectDragPreview(\n\t\tsourceId: string,\n\t\tnode: Element,\n\t\toptions: any,\n\t): Unsubscribe {\n\t\tthis.sourcePreviewNodeOptions.set(sourceId, options)\n\t\tthis.sourcePreviewNodes.set(sourceId, node)\n\n\t\treturn (): void => {\n\t\t\tthis.sourcePreviewNodes.delete(sourceId)\n\t\t\tthis.sourcePreviewNodeOptions.delete(sourceId)\n\t\t}\n\t}\n\n\tpublic connectDragSource(\n\t\tsourceId: string,\n\t\tnode: Element,\n\t\toptions: any,\n\t): Unsubscribe {\n\t\tthis.sourceNodes.set(sourceId, node)\n\t\tthis.sourceNodeOptions.set(sourceId, options)\n\n\t\tconst handleDragStart = (e: any) => this.handleDragStart(e, sourceId)\n\t\tconst handleSelectStart = (e: any) => this.handleSelectStart(e)\n\n\t\tnode.setAttribute('draggable', 'true')\n\t\tnode.addEventListener('dragstart', handleDragStart)\n\t\tnode.addEventListener('selectstart', handleSelectStart)\n\n\t\treturn (): void => {\n\t\t\tthis.sourceNodes.delete(sourceId)\n\t\t\tthis.sourceNodeOptions.delete(sourceId)\n\n\t\t\tnode.removeEventListener('dragstart', handleDragStart)\n\t\t\tnode.removeEventListener('selectstart', handleSelectStart)\n\t\t\tnode.setAttribute('draggable', 'false')\n\t\t}\n\t}\n\n\tpublic connectDropTarget(targetId: string, node: HTMLElement): Unsubscribe {\n\t\tconst handleDragEnter = (e: DragEvent) => this.handleDragEnter(e, targetId)\n\t\tconst handleDragOver = (e: DragEvent) => this.handleDragOver(e, targetId)\n\t\tconst handleDrop = (e: DragEvent) => this.handleDrop(e, targetId)\n\n\t\tnode.addEventListener('dragenter', handleDragEnter)\n\t\tnode.addEventListener('dragover', handleDragOver)\n\t\tnode.addEventListener('drop', handleDrop)\n\n\t\treturn (): void => {\n\t\t\tnode.removeEventListener('dragenter', handleDragEnter)\n\t\t\tnode.removeEventListener('dragover', handleDragOver)\n\t\t\tnode.removeEventListener('drop', handleDrop)\n\t\t}\n\t}\n\n\tprivate addEventListeners(target: Node) {\n\t\t// SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n\t\tif (!target.addEventListener) {\n\t\t\treturn\n\t\t}\n\t\ttarget.addEventListener(\n\t\t\t'dragstart',\n\t\t\tthis.handleTopDragStart as EventListener,\n\t\t)\n\t\ttarget.addEventListener('dragstart', this.handleTopDragStartCapture, true)\n\t\ttarget.addEventListener('dragend', this.handleTopDragEndCapture, true)\n\t\ttarget.addEventListener(\n\t\t\t'dragenter',\n\t\t\tthis.handleTopDragEnter as EventListener,\n\t\t)\n\t\ttarget.addEventListener(\n\t\t\t'dragenter',\n\t\t\tthis.handleTopDragEnterCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.addEventListener(\n\t\t\t'dragleave',\n\t\t\tthis.handleTopDragLeaveCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.addEventListener('dragover', this.handleTopDragOver as EventListener)\n\t\ttarget.addEventListener(\n\t\t\t'dragover',\n\t\t\tthis.handleTopDragOverCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.addEventListener('drop', this.handleTopDrop as EventListener)\n\t\ttarget.addEventListener(\n\t\t\t'drop',\n\t\t\tthis.handleTopDropCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t}\n\n\tprivate removeEventListeners(target: Node) {\n\t\t// SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n\t\tif (!target.removeEventListener) {\n\t\t\treturn\n\t\t}\n\t\ttarget.removeEventListener('dragstart', this.handleTopDragStart as any)\n\t\ttarget.removeEventListener(\n\t\t\t'dragstart',\n\t\t\tthis.handleTopDragStartCapture,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.removeEventListener('dragend', this.handleTopDragEndCapture, true)\n\t\ttarget.removeEventListener(\n\t\t\t'dragenter',\n\t\t\tthis.handleTopDragEnter as EventListener,\n\t\t)\n\t\ttarget.removeEventListener(\n\t\t\t'dragenter',\n\t\t\tthis.handleTopDragEnterCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.removeEventListener(\n\t\t\t'dragleave',\n\t\t\tthis.handleTopDragLeaveCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.removeEventListener(\n\t\t\t'dragover',\n\t\t\tthis.handleTopDragOver as EventListener,\n\t\t)\n\t\ttarget.removeEventListener(\n\t\t\t'dragover',\n\t\t\tthis.handleTopDragOverCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t\ttarget.removeEventListener('drop', this.handleTopDrop as EventListener)\n\t\ttarget.removeEventListener(\n\t\t\t'drop',\n\t\t\tthis.handleTopDropCapture as EventListener,\n\t\t\ttrue,\n\t\t)\n\t}\n\n\tprivate getCurrentSourceNodeOptions() {\n\t\tconst sourceId = this.monitor.getSourceId() as string\n\t\tconst sourceNodeOptions = this.sourceNodeOptions.get(sourceId)\n\n\t\treturn {\n\t\t\tdropEffect: this.altKeyPressed ? 'copy' : 'move',\n\t\t\t...(sourceNodeOptions || {}),\n\t\t}\n\t}\n\n\tprivate getCurrentDropEffect() {\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\t// It makes more sense to default to 'copy' for native resources\n\t\t\treturn 'copy'\n\t\t}\n\n\t\treturn this.getCurrentSourceNodeOptions().dropEffect\n\t}\n\n\tprivate getCurrentSourcePreviewNodeOptions() {\n\t\tconst sourceId = this.monitor.getSourceId() as string\n\t\tconst sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId)\n\n\t\treturn {\n\t\t\tanchorX: 0.5,\n\t\t\tanchorY: 0.5,\n\t\t\tcaptureDraggingState: false,\n\t\t\t...(sourcePreviewNodeOptions || {}),\n\t\t}\n\t}\n\n\tprivate getSourceClientOffset = (sourceId: string): XYCoord | null => {\n\t\tconst source = this.sourceNodes.get(sourceId)\n\t\treturn (source && getNodeClientOffset(source as HTMLElement)) || null\n\t}\n\n\tprivate isDraggingNativeItem() {\n\t\tconst itemType = this.monitor.getItemType()\n\t\treturn Object.keys(NativeTypes).some(\n\t\t\t(key: string) => (NativeTypes as any)[key] === itemType,\n\t\t)\n\t}\n\n\tprivate beginDragNativeItem(type: string, dataTransfer?: DataTransfer) {\n\t\tthis.clearCurrentDragSourceNode()\n\n\t\tthis.currentNativeSource = createNativeDragSource(type, dataTransfer)\n\t\tthis.currentNativeHandle = this.registry.addSource(\n\t\t\ttype,\n\t\t\tthis.currentNativeSource,\n\t\t)\n\t\tthis.actions.beginDrag([this.currentNativeHandle])\n\t}\n\n\tprivate endDragNativeItem = (): void => {\n\t\tif (!this.isDraggingNativeItem()) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.actions.endDrag()\n\t\tif (this.currentNativeHandle) {\n\t\t\tthis.registry.removeSource(this.currentNativeHandle)\n\t\t}\n\t\tthis.currentNativeHandle = null\n\t\tthis.currentNativeSource = null\n\t}\n\n\tprivate isNodeInDocument = (node: Node | null | undefined): boolean => {\n\t\t// Check the node either in the main document or in the current context\n\t\treturn Boolean(\n\t\t\tnode &&\n\t\t\t\tthis.document &&\n\t\t\t\tthis.document.body &&\n\t\t\t\tthis.document.body.contains(node),\n\t\t)\n\t}\n\n\tprivate endDragIfSourceWasRemovedFromDOM = (): void => {\n\t\tconst node = this.currentDragSourceNode\n\t\tif (node == null || this.isNodeInDocument(node)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n\t\t\tthis.actions.endDrag()\n\t\t}\n\t}\n\n\tprivate setCurrentDragSourceNode(node: Element | null) {\n\t\tthis.clearCurrentDragSourceNode()\n\t\tthis.currentDragSourceNode = node\n\n\t\t// A timeout of > 0 is necessary to resolve Firefox issue referenced\n\t\t// See:\n\t\t//   * https://github.com/react-dnd/react-dnd/pull/928\n\t\t//   * https://github.com/react-dnd/react-dnd/issues/869\n\t\tconst MOUSE_MOVE_TIMEOUT = 1000\n\n\t\t// Receiving a mouse event in the middle of a dragging operation\n\t\t// means it has ended and the drag source node disappeared from DOM,\n\t\t// so the browser didn't dispatch the dragend event.\n\t\t//\n\t\t// We need to wait before we start listening for mousemove events.\n\t\t// This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n\t\t// immediately in some browsers.\n\t\t//\n\t\t// See:\n\t\t//   * https://github.com/react-dnd/react-dnd/pull/928\n\t\t//   * https://github.com/react-dnd/react-dnd/issues/869\n\t\t//\n\t\tthis.mouseMoveTimeoutTimer = setTimeout(() => {\n\t\t\treturn this.rootElement?.addEventListener(\n\t\t\t\t'mousemove',\n\t\t\t\tthis.endDragIfSourceWasRemovedFromDOM,\n\t\t\t\ttrue,\n\t\t\t)\n\t\t}, MOUSE_MOVE_TIMEOUT) as any as number\n\t}\n\n\tprivate clearCurrentDragSourceNode() {\n\t\tif (this.currentDragSourceNode) {\n\t\t\tthis.currentDragSourceNode = null\n\n\t\t\tif (this.rootElement) {\n\t\t\t\tthis.window?.clearTimeout(this.mouseMoveTimeoutTimer || undefined)\n\t\t\t\tthis.rootElement.removeEventListener(\n\t\t\t\t\t'mousemove',\n\t\t\t\t\tthis.endDragIfSourceWasRemovedFromDOM,\n\t\t\t\t\ttrue,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tthis.mouseMoveTimeoutTimer = null\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\tpublic handleTopDragStartCapture = (): void => {\n\t\tthis.clearCurrentDragSourceNode()\n\t\tthis.dragStartSourceIds = []\n\t}\n\n\tpublic handleDragStart(e: DragEvent, sourceId: string): void {\n\t\tif (e.defaultPrevented) {\n\t\t\treturn\n\t\t}\n\n\t\tif (!this.dragStartSourceIds) {\n\t\t\tthis.dragStartSourceIds = []\n\t\t}\n\t\tthis.dragStartSourceIds.unshift(sourceId)\n\t}\n\n\tpublic handleTopDragStart = (e: DragEvent): void => {\n\t\tif (e.defaultPrevented) {\n\t\t\treturn\n\t\t}\n\n\t\tconst { dragStartSourceIds } = this\n\t\tthis.dragStartSourceIds = null\n\n\t\tconst clientOffset = getEventClientOffset(e)\n\n\t\t// Avoid crashing if we missed a drop event or our previous drag died\n\t\tif (this.monitor.isDragging()) {\n\t\t\tthis.actions.endDrag()\n\t\t}\n\n\t\t// Don't publish the source just yet (see why below)\n\t\tthis.actions.beginDrag(dragStartSourceIds || [], {\n\t\t\tpublishSource: false,\n\t\t\tgetSourceClientOffset: this.getSourceClientOffset,\n\t\t\tclientOffset,\n\t\t})\n\n\t\tconst { dataTransfer } = e\n\t\tconst nativeType = matchNativeItemType(dataTransfer)\n\n\t\tif (this.monitor.isDragging()) {\n\t\t\tif (dataTransfer && typeof dataTransfer.setDragImage === 'function') {\n\t\t\t\t// Use custom drag image if user specifies it.\n\t\t\t\t// If child drag source refuses drag but parent agrees,\n\t\t\t\t// use parent's node as drag image. Neither works in IE though.\n\t\t\t\tconst sourceId: string = this.monitor.getSourceId() as string\n\t\t\t\tconst sourceNode = this.sourceNodes.get(sourceId)\n\t\t\t\tconst dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode\n\n\t\t\t\tif (dragPreview) {\n\t\t\t\t\tconst { anchorX, anchorY, offsetX, offsetY } =\n\t\t\t\t\t\tthis.getCurrentSourcePreviewNodeOptions()\n\t\t\t\t\tconst anchorPoint = { anchorX, anchorY }\n\t\t\t\t\tconst offsetPoint = { offsetX, offsetY }\n\t\t\t\t\tconst dragPreviewOffset = getDragPreviewOffset(\n\t\t\t\t\t\tsourceNode as HTMLElement,\n\t\t\t\t\t\tdragPreview as HTMLElement,\n\t\t\t\t\t\tclientOffset,\n\t\t\t\t\t\tanchorPoint,\n\t\t\t\t\t\toffsetPoint,\n\t\t\t\t\t)\n\n\t\t\t\t\tdataTransfer.setDragImage(\n\t\t\t\t\t\tdragPreview,\n\t\t\t\t\t\tdragPreviewOffset.x,\n\t\t\t\t\t\tdragPreviewOffset.y,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Firefox won't drag without setting data\n\t\t\t\tdataTransfer?.setData('application/json', {} as any)\n\t\t\t} catch (err) {\n\t\t\t\t// IE doesn't support MIME types in setData\n\t\t\t}\n\n\t\t\t// Store drag source node so we can check whether\n\t\t\t// it is removed from DOM and trigger endDrag manually.\n\t\t\tthis.setCurrentDragSourceNode(e.target as Element)\n\n\t\t\t// Now we are ready to publish the drag source.. or are we not?\n\t\t\tconst { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions()\n\t\t\tif (!captureDraggingState) {\n\t\t\t\t// Usually we want to publish it in the next tick so that browser\n\t\t\t\t// is able to screenshot the current (not yet dragging) state.\n\t\t\t\t//\n\t\t\t\t// It also neatly avoids a situation where render() returns null\n\t\t\t\t// in the same tick for the source element, and browser freaks out.\n\t\t\t\tsetTimeout(() => this.actions.publishDragSource(), 0)\n\t\t\t} else {\n\t\t\t\t// In some cases the user may want to override this behavior, e.g.\n\t\t\t\t// to work around IE not supporting custom drag previews.\n\t\t\t\t//\n\t\t\t\t// When using a custom drag layer, the only way to prevent\n\t\t\t\t// the default drag preview from drawing in IE is to screenshot\n\t\t\t\t// the dragging state in which the node itself has zero opacity\n\t\t\t\t// and height. In this case, though, returning null from render()\n\t\t\t\t// will abruptly end the dragging, which is not obvious.\n\t\t\t\t//\n\t\t\t\t// This is the reason such behavior is strictly opt-in.\n\t\t\t\tthis.actions.publishDragSource()\n\t\t\t}\n\t\t} else if (nativeType) {\n\t\t\t// A native item (such as URL) dragged from inside the document\n\t\t\tthis.beginDragNativeItem(nativeType)\n\t\t} else if (\n\t\t\tdataTransfer &&\n\t\t\t!dataTransfer.types &&\n\t\t\t((e.target && !(e.target as Element).hasAttribute) ||\n\t\t\t\t!(e.target as Element).hasAttribute('draggable'))\n\t\t) {\n\t\t\t// Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n\t\t\t// Just let it drag. It's a native type (URL or text) and will be picked up in\n\t\t\t// dragenter handler.\n\t\t\treturn\n\t\t} else {\n\t\t\t// If by this time no drag source reacted, tell browser not to drag.\n\t\t\te.preventDefault()\n\t\t}\n\t}\n\n\tpublic handleTopDragEndCapture = (): void => {\n\t\tif (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n\t\t\t// Firefox can dispatch this event in an infinite loop\n\t\t\t// if dragend handler does something like showing an alert.\n\t\t\t// Only proceed if we have not handled it already.\n\t\t\tthis.actions.endDrag()\n\t\t}\n\t}\n\n\tpublic handleTopDragEnterCapture = (e: DragEvent): void => {\n\t\tthis.dragEnterTargetIds = []\n\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\tthis.currentNativeSource?.loadDataTransfer(e.dataTransfer)\n\t\t}\n\n\t\tconst isFirstEnter = this.enterLeaveCounter.enter(e.target)\n\t\tif (!isFirstEnter || this.monitor.isDragging()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst { dataTransfer } = e\n\t\tconst nativeType = matchNativeItemType(dataTransfer)\n\n\t\tif (nativeType) {\n\t\t\t// A native item (such as file or URL) dragged from outside the document\n\t\t\tthis.beginDragNativeItem(nativeType, dataTransfer as DataTransfer)\n\t\t}\n\t}\n\n\tpublic handleDragEnter(_e: DragEvent, targetId: string): void {\n\t\tthis.dragEnterTargetIds.unshift(targetId)\n\t}\n\n\tpublic handleTopDragEnter = (e: DragEvent): void => {\n\t\tconst { dragEnterTargetIds } = this\n\t\tthis.dragEnterTargetIds = []\n\n\t\tif (!this.monitor.isDragging()) {\n\t\t\t// This is probably a native item type we don't understand.\n\t\t\treturn\n\t\t}\n\n\t\tthis.altKeyPressed = e.altKey\n\n\t\t// If the target changes position as the result of `dragenter`, `dragover` might still\n\t\t// get dispatched despite target being no longer there. The easy solution is to check\n\t\t// whether there actually is a target before firing `hover`.\n\t\tif (dragEnterTargetIds.length > 0) {\n\t\t\tthis.actions.hover(dragEnterTargetIds, {\n\t\t\t\tclientOffset: getEventClientOffset(e),\n\t\t\t})\n\t\t}\n\n\t\tconst canDrop = dragEnterTargetIds.some((targetId) =>\n\t\t\tthis.monitor.canDropOnTarget(targetId),\n\t\t)\n\n\t\tif (canDrop) {\n\t\t\t// IE requires this to fire dragover events\n\t\t\te.preventDefault()\n\t\t\tif (e.dataTransfer) {\n\t\t\t\te.dataTransfer.dropEffect = this.getCurrentDropEffect()\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleTopDragOverCapture = (e: DragEvent): void => {\n\t\tthis.dragOverTargetIds = []\n\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\tthis.currentNativeSource?.loadDataTransfer(e.dataTransfer)\n\t\t}\n\t}\n\n\tpublic handleDragOver(_e: DragEvent, targetId: string): void {\n\t\tif (this.dragOverTargetIds === null) {\n\t\t\tthis.dragOverTargetIds = []\n\t\t}\n\t\tthis.dragOverTargetIds.unshift(targetId)\n\t}\n\n\tpublic handleTopDragOver = (e: DragEvent): void => {\n\t\tconst { dragOverTargetIds } = this\n\t\tthis.dragOverTargetIds = []\n\n\t\tif (!this.monitor.isDragging()) {\n\t\t\t// This is probably a native item type we don't understand.\n\t\t\t// Prevent default \"drop and blow away the whole document\" action.\n\t\t\te.preventDefault()\n\t\t\tif (e.dataTransfer) {\n\t\t\t\te.dataTransfer.dropEffect = 'none'\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tthis.altKeyPressed = e.altKey\n\t\tthis.lastClientOffset = getEventClientOffset(e)\n\n\t\tif (\n\t\t\tthis.hoverRafId === null &&\n\t\t\ttypeof requestAnimationFrame !== 'undefined'\n\t\t) {\n\t\t\tthis.hoverRafId = requestAnimationFrame(() => {\n\t\t\t\tif (this.monitor.isDragging()) {\n\t\t\t\t\tthis.actions.hover(dragOverTargetIds || [], {\n\t\t\t\t\t\tclientOffset: this.lastClientOffset,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tthis.hoverRafId = null\n\t\t\t})\n\t\t}\n\n\t\tconst canDrop = (dragOverTargetIds || []).some((targetId) =>\n\t\t\tthis.monitor.canDropOnTarget(targetId),\n\t\t)\n\n\t\tif (canDrop) {\n\t\t\t// Show user-specified drop effect.\n\t\t\te.preventDefault()\n\t\t\tif (e.dataTransfer) {\n\t\t\t\te.dataTransfer.dropEffect = this.getCurrentDropEffect()\n\t\t\t}\n\t\t} else if (this.isDraggingNativeItem()) {\n\t\t\t// Don't show a nice cursor but still prevent default\n\t\t\t// \"drop and blow away the whole document\" action.\n\t\t\te.preventDefault()\n\t\t} else {\n\t\t\te.preventDefault()\n\t\t\tif (e.dataTransfer) {\n\t\t\t\te.dataTransfer.dropEffect = 'none'\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleTopDragLeaveCapture = (e: DragEvent): void => {\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\te.preventDefault()\n\t\t}\n\n\t\tconst isLastLeave = this.enterLeaveCounter.leave(e.target)\n\t\tif (!isLastLeave) {\n\t\t\treturn\n\t\t}\n\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\tsetTimeout(() => this.endDragNativeItem(), 0)\n\t\t}\n\t}\n\n\tpublic handleTopDropCapture = (e: DragEvent): void => {\n\t\tthis.dropTargetIds = []\n\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\te.preventDefault()\n\t\t\tthis.currentNativeSource?.loadDataTransfer(e.dataTransfer)\n\t\t} else if (matchNativeItemType(e.dataTransfer)) {\n\t\t\t// Dragging some elements, like <a> and <img> may still behave like a native drag event,\n\t\t\t// even if the current drag event matches a user-defined type.\n\t\t\t// Stop the default behavior when we're not expecting a native item to be dropped.\n\n\t\t\te.preventDefault()\n\t\t}\n\n\t\tthis.enterLeaveCounter.reset()\n\t}\n\n\tpublic handleDrop(_e: DragEvent, targetId: string): void {\n\t\tthis.dropTargetIds.unshift(targetId)\n\t}\n\n\tpublic handleTopDrop = (e: DragEvent): void => {\n\t\tconst { dropTargetIds } = this\n\t\tthis.dropTargetIds = []\n\n\t\tthis.actions.hover(dropTargetIds, {\n\t\t\tclientOffset: getEventClientOffset(e),\n\t\t})\n\t\tthis.actions.drop({ dropEffect: this.getCurrentDropEffect() })\n\n\t\tif (this.isDraggingNativeItem()) {\n\t\t\tthis.endDragNativeItem()\n\t\t} else if (this.monitor.isDragging()) {\n\t\t\tthis.actions.endDrag()\n\t\t}\n\t}\n\n\tpublic handleSelectStart = (e: DragEvent): void => {\n\t\tconst target = e.target as HTMLElement & { dragDrop: () => void }\n\n\t\t// Only IE requires us to explicitly say\n\t\t// we want drag drop operation to start\n\t\tif (typeof target.dragDrop !== 'function') {\n\t\t\treturn\n\t\t}\n\n\t\t// Inputs and textareas should be selectable\n\t\tif (\n\t\t\ttarget.tagName === 'INPUT' ||\n\t\t\ttarget.tagName === 'SELECT' ||\n\t\t\ttarget.tagName === 'TEXTAREA' ||\n\t\t\ttarget.isContentEditable\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\t// For other targets, ask IE\n\t\t// to enable drag and drop\n\t\te.preventDefault()\n\t\ttarget.dragDrop()\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}