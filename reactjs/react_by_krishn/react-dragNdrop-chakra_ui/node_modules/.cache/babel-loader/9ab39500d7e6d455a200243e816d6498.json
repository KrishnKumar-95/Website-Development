{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { addSource, addTarget, removeSource, removeTarget } from '../actions/registry.mjs';\nimport { getNextUniqueId } from '../utils/getNextUniqueId.mjs';\nimport { HandlerRole } from '../interfaces.mjs';\nimport { validateSourceContract, validateTargetContract, validateType } from '../contracts.mjs';\nimport { asap } from '@react-dnd/asap';\n\nfunction getNextHandlerId(role) {\n  const id = getNextUniqueId().toString();\n\n  switch (role) {\n    case HandlerRole.SOURCE:\n      return `S${id}`;\n\n    case HandlerRole.TARGET:\n      return `T${id}`;\n\n    default:\n      throw new Error(`Unknown Handler Role: ${role}`);\n  }\n}\n\nfunction parseRoleFromHandlerId(handlerId) {\n  switch (handlerId[0]) {\n    case 'S':\n      return HandlerRole.SOURCE;\n\n    case 'T':\n      return HandlerRole.TARGET;\n\n    default:\n      throw new Error(`Cannot parse handler ID: ${handlerId}`);\n  }\n}\n\nfunction mapContainsValue(map, searchValue) {\n  const entries = map.entries();\n  let isDone = false;\n\n  do {\n    const {\n      done,\n      value: [, value]\n    } = entries.next();\n\n    if (value === searchValue) {\n      return true;\n    }\n\n    isDone = !!done;\n  } while (!isDone);\n\n  return false;\n}\n\nexport class HandlerRegistryImpl {\n  addSource(type, source) {\n    validateType(type);\n    validateSourceContract(source);\n    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n    this.store.dispatch(addSource(sourceId));\n    return sourceId;\n  }\n\n  addTarget(type, target) {\n    validateType(type, true);\n    validateTargetContract(target);\n    const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n    this.store.dispatch(addTarget(targetId));\n    return targetId;\n  }\n\n  containsHandler(handler) {\n    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n  }\n\n  getSource(sourceId) {\n    let includePinned = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n    const isPinned = includePinned && sourceId === this.pinnedSourceId;\n    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n    return source;\n  }\n\n  getTarget(targetId) {\n    invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n    return this.dropTargets.get(targetId);\n  }\n\n  getSourceType(sourceId) {\n    invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n    return this.types.get(sourceId);\n  }\n\n  getTargetType(targetId) {\n    invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n    return this.types.get(targetId);\n  }\n\n  isSourceId(handlerId) {\n    const role = parseRoleFromHandlerId(handlerId);\n    return role === HandlerRole.SOURCE;\n  }\n\n  isTargetId(handlerId) {\n    const role = parseRoleFromHandlerId(handlerId);\n    return role === HandlerRole.TARGET;\n  }\n\n  removeSource(sourceId) {\n    invariant(this.getSource(sourceId), 'Expected an existing source.');\n    this.store.dispatch(removeSource(sourceId));\n    asap(() => {\n      this.dragSources.delete(sourceId);\n      this.types.delete(sourceId);\n    });\n  }\n\n  removeTarget(targetId) {\n    invariant(this.getTarget(targetId), 'Expected an existing target.');\n    this.store.dispatch(removeTarget(targetId));\n    this.dropTargets.delete(targetId);\n    this.types.delete(targetId);\n  }\n\n  pinSource(sourceId) {\n    const source = this.getSource(sourceId);\n    invariant(source, 'Expected an existing source.');\n    this.pinnedSourceId = sourceId;\n    this.pinnedSource = source;\n  }\n\n  unpinSource() {\n    invariant(this.pinnedSource, 'No source is pinned at the time.');\n    this.pinnedSourceId = null;\n    this.pinnedSource = null;\n  }\n\n  addHandler(role, type, handler) {\n    const id = getNextHandlerId(role);\n    this.types.set(id, type);\n\n    if (role === HandlerRole.SOURCE) {\n      this.dragSources.set(id, handler);\n    } else if (role === HandlerRole.TARGET) {\n      this.dropTargets.set(id, handler);\n    }\n\n    return id;\n  }\n\n  constructor(store) {\n    this.types = new Map();\n    this.dragSources = new Map();\n    this.dropTargets = new Map();\n    this.pinnedSourceId = null;\n    this.pinnedSource = null;\n    this.store = store;\n  }\n\n}","map":{"version":3,"sources":["/home/ubkrishn/Desktop/Website Development/reactjs/react_by_krishn/react-dragNdrop-chakra_ui/node_modules/dnd-core/src/classes/HandlerRegistryImpl.ts"],"names":["invariant","addSource","addTarget","removeSource","removeTarget","getNextUniqueId","HandlerRole","validateSourceContract","validateTargetContract","validateType","asap","getNextHandlerId","role","id","toString","SOURCE","TARGET","Error","parseRoleFromHandlerId","handlerId","mapContainsValue","map","searchValue","entries","isDone","done","value","next","HandlerRegistryImpl","types","Map","dragSources","dropTargets","pinnedSourceId","pinnedSource","store","type","source","sourceId","addHandler","dispatch","target","targetId","containsHandler","handler","getSource","includePinned","isSourceId","isPinned","get","getTarget","isTargetId","getSourceType","getTargetType","delete","pinSource","unpinSource","set"],"mappings":"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","sourcesContent":["import type { Store } from 'redux'\nimport { invariant } from '@react-dnd/invariant'\nimport {\n\taddSource,\n\taddTarget,\n\tremoveSource,\n\tremoveTarget,\n} from '../actions/registry.js'\nimport { getNextUniqueId } from '../utils/getNextUniqueId.js'\nimport type { State } from '../reducers/index.js'\nimport {\n\tDragSource,\n\tDropTarget,\n\tSourceType,\n\tTargetType,\n\tIdentifier,\n\tHandlerRole,\n\tHandlerRegistry,\n} from '../interfaces.js'\nimport {\n\tvalidateSourceContract,\n\tvalidateTargetContract,\n\tvalidateType,\n} from '../contracts.js'\nimport { asap } from '@react-dnd/asap'\n\nfunction getNextHandlerId(role: HandlerRole): string {\n\tconst id = getNextUniqueId().toString()\n\tswitch (role) {\n\t\tcase HandlerRole.SOURCE:\n\t\t\treturn `S${id}`\n\t\tcase HandlerRole.TARGET:\n\t\t\treturn `T${id}`\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown Handler Role: ${role}`)\n\t}\n}\n\nfunction parseRoleFromHandlerId(handlerId: string) {\n\tswitch (handlerId[0]) {\n\t\tcase 'S':\n\t\t\treturn HandlerRole.SOURCE\n\t\tcase 'T':\n\t\t\treturn HandlerRole.TARGET\n\t\tdefault:\n\t\t\tthrow new Error(`Cannot parse handler ID: ${handlerId}`)\n\t}\n}\n\nfunction mapContainsValue<T>(map: Map<string, T>, searchValue: T) {\n\tconst entries = map.entries()\n\tlet isDone = false\n\tdo {\n\t\tconst {\n\t\t\tdone,\n\t\t\tvalue: [, value],\n\t\t} = entries.next()\n\t\tif (value === searchValue) {\n\t\t\treturn true\n\t\t}\n\t\tisDone = !!done\n\t} while (!isDone)\n\treturn false\n}\n\nexport class HandlerRegistryImpl implements HandlerRegistry {\n\tprivate types: Map<string, SourceType | TargetType> = new Map()\n\tprivate dragSources: Map<string, DragSource> = new Map()\n\tprivate dropTargets: Map<string, DropTarget> = new Map()\n\tprivate pinnedSourceId: string | null = null\n\tprivate pinnedSource: any = null\n\tprivate store: Store<State>\n\n\tpublic constructor(store: Store<State>) {\n\t\tthis.store = store\n\t}\n\n\tpublic addSource(type: SourceType, source: DragSource): string {\n\t\tvalidateType(type)\n\t\tvalidateSourceContract(source)\n\n\t\tconst sourceId = this.addHandler(HandlerRole.SOURCE, type, source)\n\t\tthis.store.dispatch(addSource(sourceId))\n\t\treturn sourceId\n\t}\n\n\tpublic addTarget(type: TargetType, target: DropTarget): string {\n\t\tvalidateType(type, true)\n\t\tvalidateTargetContract(target)\n\n\t\tconst targetId = this.addHandler(HandlerRole.TARGET, type, target)\n\t\tthis.store.dispatch(addTarget(targetId))\n\t\treturn targetId\n\t}\n\n\tpublic containsHandler(handler: DragSource | DropTarget): boolean {\n\t\treturn (\n\t\t\tmapContainsValue(this.dragSources, handler) ||\n\t\t\tmapContainsValue(this.dropTargets, handler)\n\t\t)\n\t}\n\n\tpublic getSource(sourceId: string, includePinned = false): DragSource {\n\t\tinvariant(this.isSourceId(sourceId), 'Expected a valid source ID.')\n\t\tconst isPinned = includePinned && sourceId === this.pinnedSourceId\n\t\tconst source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId)\n\t\treturn source\n\t}\n\n\tpublic getTarget(targetId: string): DropTarget {\n\t\tinvariant(this.isTargetId(targetId), 'Expected a valid target ID.')\n\t\treturn this.dropTargets.get(targetId) as DropTarget\n\t}\n\n\tpublic getSourceType(sourceId: string): Identifier {\n\t\tinvariant(this.isSourceId(sourceId), 'Expected a valid source ID.')\n\t\treturn this.types.get(sourceId) as Identifier\n\t}\n\n\tpublic getTargetType(targetId: string): Identifier | Identifier[] {\n\t\tinvariant(this.isTargetId(targetId), 'Expected a valid target ID.')\n\t\treturn this.types.get(targetId) as Identifier | Identifier[]\n\t}\n\n\tpublic isSourceId(handlerId: string): boolean {\n\t\tconst role = parseRoleFromHandlerId(handlerId)\n\t\treturn role === HandlerRole.SOURCE\n\t}\n\n\tpublic isTargetId(handlerId: string): boolean {\n\t\tconst role = parseRoleFromHandlerId(handlerId)\n\t\treturn role === HandlerRole.TARGET\n\t}\n\n\tpublic removeSource(sourceId: string): void {\n\t\tinvariant(this.getSource(sourceId), 'Expected an existing source.')\n\t\tthis.store.dispatch(removeSource(sourceId))\n\t\tasap(() => {\n\t\t\tthis.dragSources.delete(sourceId)\n\t\t\tthis.types.delete(sourceId)\n\t\t})\n\t}\n\n\tpublic removeTarget(targetId: string): void {\n\t\tinvariant(this.getTarget(targetId), 'Expected an existing target.')\n\t\tthis.store.dispatch(removeTarget(targetId))\n\t\tthis.dropTargets.delete(targetId)\n\t\tthis.types.delete(targetId)\n\t}\n\n\tpublic pinSource(sourceId: string): void {\n\t\tconst source = this.getSource(sourceId)\n\t\tinvariant(source, 'Expected an existing source.')\n\n\t\tthis.pinnedSourceId = sourceId\n\t\tthis.pinnedSource = source\n\t}\n\n\tpublic unpinSource(): void {\n\t\tinvariant(this.pinnedSource, 'No source is pinned at the time.')\n\n\t\tthis.pinnedSourceId = null\n\t\tthis.pinnedSource = null\n\t}\n\n\tprivate addHandler(\n\t\trole: HandlerRole,\n\t\ttype: SourceType | TargetType,\n\t\thandler: DragSource | DropTarget,\n\t): string {\n\t\tconst id = getNextHandlerId(role)\n\t\tthis.types.set(id, type)\n\t\tif (role === HandlerRole.SOURCE) {\n\t\t\tthis.dragSources.set(id, handler as DragSource)\n\t\t} else if (role === HandlerRole.TARGET) {\n\t\t\tthis.dropTargets.set(id, handler as DropTarget)\n\t\t}\n\t\treturn id\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}