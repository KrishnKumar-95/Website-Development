{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from '../utils/matchesType.mjs';\nimport { getSourceClientOffset, getDifferenceFromInitialOffset } from '../utils/coords.mjs';\nimport { areDirty } from '../utils/dirtiness.mjs';\nexport class DragDropMonitorImpl {\n  subscribeToStateChange(listener) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      handlerIds\n    } = options;\n    invariant(typeof listener === 'function', 'listener must be a function.');\n    invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n    let prevStateId = this.store.getState().stateId;\n\n    const handleChange = () => {\n      const state = this.store.getState();\n      const currentStateId = state.stateId;\n\n      try {\n        const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n\n        if (!canSkipListener) {\n          listener();\n        }\n      } finally {\n        prevStateId = currentStateId;\n      }\n    };\n\n    return this.store.subscribe(handleChange);\n  }\n\n  subscribeToOffsetChange(listener) {\n    invariant(typeof listener === 'function', 'listener must be a function.');\n    let previousState = this.store.getState().dragOffset;\n\n    const handleChange = () => {\n      const nextState = this.store.getState().dragOffset;\n\n      if (nextState === previousState) {\n        return;\n      }\n\n      previousState = nextState;\n      listener();\n    };\n\n    return this.store.subscribe(handleChange);\n  }\n\n  canDragSource(sourceId) {\n    if (!sourceId) {\n      return false;\n    }\n\n    const source = this.registry.getSource(sourceId);\n    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n\n    if (this.isDragging()) {\n      return false;\n    }\n\n    return source.canDrag(this, sourceId);\n  }\n\n  canDropOnTarget(targetId) {\n    // undefined on initial render\n    if (!targetId) {\n      return false;\n    }\n\n    const target = this.registry.getTarget(targetId);\n    invariant(target, `Expected to find a valid target. targetId=${targetId}`);\n\n    if (!this.isDragging() || this.didDrop()) {\n      return false;\n    }\n\n    const targetType = this.registry.getTargetType(targetId);\n    const draggedItemType = this.getItemType();\n    return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n  }\n\n  isDragging() {\n    return Boolean(this.getItemType());\n  }\n\n  isDraggingSource(sourceId) {\n    // undefined on initial render\n    if (!sourceId) {\n      return false;\n    }\n\n    const source = this.registry.getSource(sourceId, true);\n    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n\n    if (!this.isDragging() || !this.isSourcePublic()) {\n      return false;\n    }\n\n    const sourceType = this.registry.getSourceType(sourceId);\n    const draggedItemType = this.getItemType();\n\n    if (sourceType !== draggedItemType) {\n      return false;\n    }\n\n    return source.isDragging(this, sourceId);\n  }\n\n  isOverTarget(targetId) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      shallow: false\n    };\n\n    // undefined on initial render\n    if (!targetId) {\n      return false;\n    }\n\n    const {\n      shallow\n    } = options;\n\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    const targetType = this.registry.getTargetType(targetId);\n    const draggedItemType = this.getItemType();\n\n    if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n      return false;\n    }\n\n    const targetIds = this.getTargetIds();\n\n    if (!targetIds.length) {\n      return false;\n    }\n\n    const index = targetIds.indexOf(targetId);\n\n    if (shallow) {\n      return index === targetIds.length - 1;\n    } else {\n      return index > -1;\n    }\n  }\n\n  getItemType() {\n    return this.store.getState().dragOperation.itemType;\n  }\n\n  getItem() {\n    return this.store.getState().dragOperation.item;\n  }\n\n  getSourceId() {\n    return this.store.getState().dragOperation.sourceId;\n  }\n\n  getTargetIds() {\n    return this.store.getState().dragOperation.targetIds;\n  }\n\n  getDropResult() {\n    return this.store.getState().dragOperation.dropResult;\n  }\n\n  didDrop() {\n    return this.store.getState().dragOperation.didDrop;\n  }\n\n  isSourcePublic() {\n    return Boolean(this.store.getState().dragOperation.isSourcePublic);\n  }\n\n  getInitialClientOffset() {\n    return this.store.getState().dragOffset.initialClientOffset;\n  }\n\n  getInitialSourceClientOffset() {\n    return this.store.getState().dragOffset.initialSourceClientOffset;\n  }\n\n  getClientOffset() {\n    return this.store.getState().dragOffset.clientOffset;\n  }\n\n  getSourceClientOffset() {\n    return getSourceClientOffset(this.store.getState().dragOffset);\n  }\n\n  getDifferenceFromInitialOffset() {\n    return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n  }\n\n  constructor(store, registry) {\n    this.store = store;\n    this.registry = registry;\n  }\n\n}","map":{"version":3,"sources":["/home/ubkrishn/Desktop/Website Development/reactjs/react_by_krishn/react-dragNdrop-chakra_ui/node_modules/dnd-core/src/classes/DragDropMonitorImpl.ts"],"names":["invariant","matchesType","getSourceClientOffset","getDifferenceFromInitialOffset","areDirty","DragDropMonitorImpl","store","registry","subscribeToStateChange","listener","options","handlerIds","Array","isArray","prevStateId","getState","stateId","handleChange","state","currentStateId","canSkipListener","dirtyHandlerIds","subscribe","subscribeToOffsetChange","previousState","dragOffset","nextState","canDragSource","sourceId","source","getSource","isDragging","canDrag","canDropOnTarget","targetId","target","getTarget","didDrop","targetType","getTargetType","draggedItemType","getItemType","canDrop","Boolean","isDraggingSource","isSourcePublic","sourceType","getSourceType","isOverTarget","shallow","targetIds","getTargetIds","length","index","indexOf","dragOperation","itemType","getItem","item","getSourceId","getDropResult","dropResult","getInitialClientOffset","initialClientOffset","getInitialSourceClientOffset","initialSourceClientOffset","getClientOffset","clientOffset"],"mappings":"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","sourcesContent":["import type { Store } from 'redux'\nimport { invariant } from '@react-dnd/invariant'\nimport { matchesType } from '../utils/matchesType.js'\nimport {\n\tgetSourceClientOffset,\n\tgetDifferenceFromInitialOffset,\n} from '../utils/coords.js'\nimport { areDirty } from '../utils/dirtiness.js'\nimport type { State } from '../reducers/index.js'\nimport type {\n\tDragDropMonitor,\n\tListener,\n\tUnsubscribe,\n\tXYCoord,\n\tHandlerRegistry,\n\tIdentifier,\n} from '../interfaces.js'\n\nexport class DragDropMonitorImpl implements DragDropMonitor {\n\tprivate store: Store<State>\n\tpublic readonly registry: HandlerRegistry\n\n\tpublic constructor(store: Store<State>, registry: HandlerRegistry) {\n\t\tthis.store = store\n\t\tthis.registry = registry\n\t}\n\n\tpublic subscribeToStateChange(\n\t\tlistener: Listener,\n\t\toptions: { handlerIds?: string[] } = {},\n\t): Unsubscribe {\n\t\tconst { handlerIds } = options\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\t\tinvariant(\n\t\t\ttypeof handlerIds === 'undefined' || Array.isArray(handlerIds),\n\t\t\t'handlerIds, when specified, must be an array of strings.',\n\t\t)\n\n\t\tlet prevStateId = this.store.getState().stateId\n\t\tconst handleChange = () => {\n\t\t\tconst state = this.store.getState()\n\t\t\tconst currentStateId = state.stateId\n\t\t\ttry {\n\t\t\t\tconst canSkipListener =\n\t\t\t\t\tcurrentStateId === prevStateId ||\n\t\t\t\t\t(currentStateId === prevStateId + 1 &&\n\t\t\t\t\t\t!areDirty(state.dirtyHandlerIds, handlerIds))\n\n\t\t\t\tif (!canSkipListener) {\n\t\t\t\t\tlistener()\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tprevStateId = currentStateId\n\t\t\t}\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic subscribeToOffsetChange(listener: Listener): Unsubscribe {\n\t\tinvariant(typeof listener === 'function', 'listener must be a function.')\n\n\t\tlet previousState = this.store.getState().dragOffset\n\t\tconst handleChange = () => {\n\t\t\tconst nextState = this.store.getState().dragOffset\n\t\t\tif (nextState === previousState) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpreviousState = nextState\n\t\t\tlistener()\n\t\t}\n\n\t\treturn this.store.subscribe(handleChange)\n\t}\n\n\tpublic canDragSource(sourceId: string | undefined): boolean {\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.canDrag(this, sourceId)\n\t}\n\n\tpublic canDropOnTarget(targetId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\t\tconst target = this.registry.getTarget(targetId)\n\t\tinvariant(target, `Expected to find a valid target. targetId=${targetId}`)\n\n\t\tif (!this.isDragging() || this.didDrop()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\treturn (\n\t\t\tmatchesType(targetType, draggedItemType) && target.canDrop(this, targetId)\n\t\t)\n\t}\n\n\tpublic isDragging(): boolean {\n\t\treturn Boolean(this.getItemType())\n\t}\n\n\tpublic isDraggingSource(sourceId: string | undefined): boolean {\n\t\t// undefined on initial render\n\t\tif (!sourceId) {\n\t\t\treturn false\n\t\t}\n\t\tconst source = this.registry.getSource(sourceId, true)\n\t\tinvariant(source, `Expected to find a valid source. sourceId=${sourceId}`)\n\n\t\tif (!this.isDragging() || !this.isSourcePublic()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst sourceType = this.registry.getSourceType(sourceId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (sourceType !== draggedItemType) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn source.isDragging(this, sourceId)\n\t}\n\n\tpublic isOverTarget(\n\t\ttargetId: string | undefined,\n\t\toptions = { shallow: false },\n\t): boolean {\n\t\t// undefined on initial render\n\t\tif (!targetId) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst { shallow } = options\n\t\tif (!this.isDragging()) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetType = this.registry.getTargetType(targetId)\n\t\tconst draggedItemType = this.getItemType()\n\t\tif (draggedItemType && !matchesType(targetType, draggedItemType)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst targetIds = this.getTargetIds()\n\t\tif (!targetIds.length) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst index = targetIds.indexOf(targetId)\n\t\tif (shallow) {\n\t\t\treturn index === targetIds.length - 1\n\t\t} else {\n\t\t\treturn index > -1\n\t\t}\n\t}\n\n\tpublic getItemType(): Identifier {\n\t\treturn this.store.getState().dragOperation.itemType as Identifier\n\t}\n\n\tpublic getItem(): any {\n\t\treturn this.store.getState().dragOperation.item\n\t}\n\n\tpublic getSourceId(): string | null {\n\t\treturn this.store.getState().dragOperation.sourceId\n\t}\n\n\tpublic getTargetIds(): string[] {\n\t\treturn this.store.getState().dragOperation.targetIds\n\t}\n\n\tpublic getDropResult(): any {\n\t\treturn this.store.getState().dragOperation.dropResult\n\t}\n\n\tpublic didDrop(): boolean {\n\t\treturn this.store.getState().dragOperation.didDrop\n\t}\n\n\tpublic isSourcePublic(): boolean {\n\t\treturn Boolean(this.store.getState().dragOperation.isSourcePublic)\n\t}\n\n\tpublic getInitialClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialClientOffset\n\t}\n\n\tpublic getInitialSourceClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.initialSourceClientOffset\n\t}\n\n\tpublic getClientOffset(): XYCoord | null {\n\t\treturn this.store.getState().dragOffset.clientOffset\n\t}\n\n\tpublic getSourceClientOffset(): XYCoord | null {\n\t\treturn getSourceClientOffset(this.store.getState().dragOffset)\n\t}\n\n\tpublic getDifferenceFromInitialOffset(): XYCoord | null {\n\t\treturn getDifferenceFromInitialOffset(this.store.getState().dragOffset)\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}